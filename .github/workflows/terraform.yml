name: Infraestructura y Despliegue

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente a desplegar (dev, stg, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stg
          - prod
      terraform_action:
        description: 'Acción de Terraform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      skip_image_build:
        description: 'Omitir construcción de imágenes'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    name: Despliegue de Infraestructura
    runs-on: ubuntu-latest
    
    # Establecer el ambiente según el contexto
    env:
      # Por defecto usa 'dev' para develop branch, 'prod' para main, o el input manual
      ENV: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/develop' && 'dev') || 'dev' }}
      REGION_DEV: us-east-1
      REGION_PROD: us-west-2
      TF_ACTION: ${{ github.event.inputs.terraform_action || 'plan' }}
      
    steps:
      - name: Checkout del código
        uses: actions/checkout@v3
      
      - name: Configurar AWS CLI
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}
      
      - name: Obtener ID de cuenta AWS
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "Ambiente: ${{ env.ENV }}"
          echo "Región: ${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          echo "Acción Terraform: ${{ env.TF_ACTION }}"
      
      - name: Instalar Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.6
      
      # PASO 1: Configurar buckets para Terraform state
      - name: Crear y configurar buckets para Terraform state
        run: |
          # Definir la región correcta según el ambiente
          REGION="${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          
          echo "=== Creando buckets para Terraform state ==="
          
          # Crear buckets (ignorar errores si ya existen)
          aws s3 mb s3://finaktiva-terraform-state-dev --region ${{ env.REGION_DEV }} || true
          aws s3 mb s3://finaktiva-terraform-state-stg --region ${{ env.REGION_DEV }} || true
          aws s3 mb s3://finaktiva-terraform-state-prod --region ${{ env.REGION_PROD }} || true
          
          # Habilitar versionado
          aws s3api put-bucket-versioning --bucket finaktiva-terraform-state-dev --versioning-configuration Status=Enabled
          aws s3api put-bucket-versioning --bucket finaktiva-terraform-state-stg --versioning-configuration Status=Enabled
          aws s3api put-bucket-versioning --bucket finaktiva-terraform-state-prod --versioning-configuration Status=Enabled
          
          # Crear tabla DynamoDB para lock (ignorar errores si ya existe)
          aws dynamodb create-table \
              --table-name terraform-state-lock \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
              --region $REGION || true
              
          echo "=== Configuración de Terraform state completada ==="
      
      # PASO 2: Crear repositorios ECR
      - name: Crear repositorios ECR
        run: |
          REGION="${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          
          echo "=== Creando repositorios ECR ==="
          
          # Crear repositorios con nombres que coincidan con el módulo Terraform
          aws ecr delete-repository --repository-name ${{ env.ENV }}-app1 --force || true
          aws ecr delete-repository --repository-name ${{ env.ENV }}-app2 --force || true
          
          aws ecr create-repository --repository-name ${{ env.ENV }}-app1 --region $REGION || true
          aws ecr create-repository --repository-name ${{ env.ENV }}-app2 --region $REGION || true
          
          echo "=== Repositorios ECR creados correctamente ==="
      
      # PASO 3: Configurar módulo ECR
      - name: Configurar módulo ECR
        run: |
          ECR_MODULE_DIR="docs/terraform-iac/terraform/modulos/ecr"
          mkdir -p $ECR_MODULE_DIR
          
          # Data source para obtener los repositorios ECR existentes
          echo '# Data source para obtener los repositorios ECR existentes' > $ECR_MODULE_DIR/main.tf
          echo 'data "aws_ecr_repository" "app_repo" {' >> $ECR_MODULE_DIR/main.tf
          echo '  count = length(var.app_names)' >> $ECR_MODULE_DIR/main.tf
          echo '  name  = "${var.environment}-${var.app_names[count.index]}"' >> $ECR_MODULE_DIR/main.tf
          echo '}' >> $ECR_MODULE_DIR/main.tf
          
          # Crear o actualizar variables.tf
          if [ ! -f "$ECR_MODULE_DIR/variables.tf" ]; then
            echo "Creando variables.tf del módulo ECR..."
            echo 'variable "app_names" {' > $ECR_MODULE_DIR/variables.tf
            echo '  description = "Nombres de las aplicaciones"' >> $ECR_MODULE_DIR/variables.tf
            echo '  type        = list(string)' >> $ECR_MODULE_DIR/variables.tf
            echo '  default     = ["app1", "app2"]' >> $ECR_MODULE_DIR/variables.tf
            echo '}' >> $ECR_MODULE_DIR/variables.tf
            echo '' >> $ECR_MODULE_DIR/variables.tf
            echo 'variable "environment" {' >> $ECR_MODULE_DIR/variables.tf
            echo '  description = "Ambiente (dev, stg, prod)"' >> $ECR_MODULE_DIR/variables.tf
            echo '  type        = string' >> $ECR_MODULE_DIR/variables.tf
            echo '  default     = "dev"' >> $ECR_MODULE_DIR/variables.tf
            echo '}' >> $ECR_MODULE_DIR/variables.tf
          fi
          
          # Crear o actualizar outputs.tf
          if [ ! -f "$ECR_MODULE_DIR/outputs.tf" ]; then
            echo "Creando outputs.tf del módulo ECR..."
            echo 'output "repository_urls" {' > $ECR_MODULE_DIR/outputs.tf
            echo '  description = "URLs de los repositorios ECR"' >> $ECR_MODULE_DIR/outputs.tf
            echo '  value       = data.aws_ecr_repository.app_repo[*].repository_url' >> $ECR_MODULE_DIR/outputs.tf
            echo '}' >> $ECR_MODULE_DIR/outputs.tf
          fi
      
      # PASO 4: Asegurar que existan Dockerfiles
      - name: Asegurar que existan Dockerfiles
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        run: |
          # Verificar y crear Dockerfile para app1 si no existe
          if [ ! -f apps/app1/Dockerfile ]; then
            echo "Creando Dockerfile temporal para app1..."
            mkdir -p apps/app1/src
            
            echo 'FROM alpine:latest' > apps/app1/Dockerfile
            echo 'WORKDIR /app' >> apps/app1/Dockerfile
            echo 'COPY src/ .' >> apps/app1/Dockerfile
            echo 'CMD ["echo", "Esta es una imagen temporal para app1"]' >> apps/app1/Dockerfile
          fi
          
          # Verificar y crear Dockerfile para app2 si no existe
          if [ ! -f apps/app2/Dockerfile ]; then
            echo "Creando Dockerfile temporal para app2..."
            mkdir -p apps/app2/src
            
            echo 'FROM alpine:latest' > apps/app2/Dockerfile
            echo 'WORKDIR /app' >> apps/app2/Dockerfile
            echo 'COPY src/ .' >> apps/app2/Dockerfile
            echo 'CMD ["echo", "Esta es una imagen temporal para app2"]' >> apps/app2/Dockerfile
          fi
          
          # Verificar que los directorios src contengan al menos un archivo
          if [ ! "$(ls -A apps/app1/src 2>/dev/null)" ]; then
            echo "Creando archivo de ejemplo en app1/src..."
            echo "console.log('Aplicación 1');" > apps/app1/src/index.js
          fi
          
          if [ ! "$(ls -A apps/app2/src 2>/dev/null)" ]; then
            echo "Creando archivo de ejemplo en app2/src..."
            echo "console.log('Aplicación 2');" > apps/app2/src/index.js
          fi
      
      # PASO 5: Autenticar, construir y publicar imágenes Docker a ECR
      - name: Configurar Docker Buildx
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        uses: docker/setup-buildx-action@v2
      
      - name: Autenticar en ECR
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        id: ecr-login
        run: |
          REGION="${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.$REGION.amazonaws.com
      
      - name: Construir y publicar imagen app1
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        uses: docker/build-push-action@v4
        with:
          context: ./apps/app1
          push: true
          tags: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}.amazonaws.com/${{ env.ENV }}-app1:latest
      
      - name: Construir y publicar imagen app2
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        uses: docker/build-push-action@v4
        with:
          context: ./apps/app2
          push: true
          tags: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}.amazonaws.com/${{ env.ENV }}-app2:latest
      
      # PASO 6: Preparar y ejecutar Terraform
      - name: Preparar archivos de Terraform
        run: |
          TERRAFORM_DIR="docs/terraform-iac/terraform"
          mkdir -p $TERRAFORM_DIR
          
          # Crear o actualizar backend.tf
          echo 'terraform {' > $TERRAFORM_DIR/backend.tf
          echo '  backend "s3" {' >> $TERRAFORM_DIR/backend.tf
          echo '    # Los valores específicos se pasan en la línea de comandos de init' >> $TERRAFORM_DIR/backend.tf
          echo '  }' >> $TERRAFORM_DIR/backend.tf
          echo '}' >> $TERRAFORM_DIR/backend.tf
          
          # Asegurar que main.tf referencia al módulo ECR
          echo 'provider "aws" {' > $TERRAFORM_DIR/main.tf
          echo '  region = var.region' >> $TERRAFORM_DIR/main.tf
          echo '}' >> $TERRAFORM_DIR/main.tf
          echo '' >> $TERRAFORM_DIR/main.tf
          echo '# Módulo ECR' >> $TERRAFORM_DIR/main.tf
          echo 'module "ecr" {' >> $TERRAFORM_DIR/main.tf
          echo '  source      = "./modulos/ecr"' >> $TERRAFORM_DIR/main.tf
          echo '  environment = var.environment' >> $TERRAFORM_DIR/main.tf
          echo '  app_names   = ["app1", "app2"]' >> $TERRAFORM_DIR/main.tf
          echo '}' >> $TERRAFORM_DIR/main.tf
          
          # Verificar variables.tf
          echo 'variable "environment" {' > $TERRAFORM_DIR/variables.tf
          echo '  description = "Ambiente (dev, stg, prod)"' >> $TERRAFORM_DIR/variables.tf
          echo '  type        = string' >> $TERRAFORM_DIR/variables.tf
          echo '  default     = "dev"' >> $TERRAFORM_DIR/variables.tf
          echo '}' >> $TERRAFORM_DIR/variables.tf
          echo '' >> $TERRAFORM_DIR/variables.tf
          echo 'variable "region" {' >> $TERRAFORM_DIR/variables.tf
          echo '  description = "Región de AWS"' >> $TERRAFORM_DIR/variables.tf
          echo '  type        = string' >> $TERRAFORM_DIR/variables.tf
          echo '  default     = "us-east-1"' >> $TERRAFORM_DIR/variables.tf
          echo '}' >> $TERRAFORM_DIR/variables.tf
          
          # Verificar archivos de ambiente
          mkdir -p $TERRAFORM_DIR/ambientes/${{ env.ENV }}
          
          # Crear el archivo terraform.tfvars
          if [ "${{ env.ENV }}" = "prod" ]; then
            echo "environment = \"prod\"" > $TERRAFORM_DIR/ambientes/${{ env.ENV }}/terraform.tfvars
            echo "region = \"${{ env.REGION_PROD }}\"" >> $TERRAFORM_DIR/ambientes/${{ env.ENV }}/terraform.tfvars
          else
            echo "environment = \"${{ env.ENV }}\"" > $TERRAFORM_DIR/ambientes/${{ env.ENV }}/terraform.tfvars
            echo "region = \"${{ env.REGION_DEV }}\"" >> $TERRAFORM_DIR/ambientes/${{ env.ENV }}/terraform.tfvars
          fi
      
      - name: Inicializar Terraform
        run: |
          cd docs/terraform-iac/terraform
          REGION="${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          
          terraform init \
            -backend-config="bucket=finaktiva-terraform-state-${{ env.ENV }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=$REGION" \
            -backend-config="dynamodb_table=terraform-state-lock"
      
      - name: Plan de Terraform
        if: ${{ env.TF_ACTION == 'plan' || env.TF_ACTION == 'apply' }}
        run: |
          cd docs/terraform-iac/terraform
          REGION="${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          
          terraform plan \
            -var="environment=${{ env.ENV }}" \
            -var="region=$REGION" \
            -var-file="ambientes/${{ env.ENV }}/terraform.tfvars" \
            -out=tfplan
            
          # Si es solo plan, mostramos un mensaje explicativo
          if [ "${{ env.TF_ACTION }}" = "plan" ]; then
            echo "============================================================"
            echo "Plan de Terraform completado. No se aplicarán cambios."
            echo "Para aplicar estos cambios, ejecuta el workflow con la acción 'apply'."
            echo "============================================================"
          fi
      
      # Aplicar cambios si la acción es 'apply' y no es un PR
      - name: Aplicar Terraform
        if: ${{ env.TF_ACTION == 'apply' && github.event_name != 'pull_request' }}
        run: |
          cd docs/terraform-iac/terraform
          echo "============================================================"
          echo "Aplicando cambios de infraestructura en ambiente ${{ env.ENV }}..."
          echo "============================================================"
          terraform apply -auto-approve tfplan
      
      # Destruir infraestructura si la acción es 'destroy'
      - name: Destruir infraestructura
        if: ${{ env.TF_ACTION == 'destroy' && github.event_name != 'pull_request' }}
        run: |
          cd docs/terraform-iac/terraform
          REGION="${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          
          echo "============================================================"
          echo "ATENCIÓN: Se destruirá toda la infraestructura en ambiente ${{ env.ENV }}."
          echo "============================================================"
          
          terraform destroy -auto-approve \
            -var="environment=${{ env.ENV }}" \
            -var="region=$REGION" \
            -var-file="ambientes/${{ env.ENV }}/terraform.tfvars"
      
      - name: Notificar completado
        run: |
          echo "============================================================"
          echo "Pipeline completado exitosamente"
          echo "============================================================"
          echo "Ambiente: ${{ env.ENV }}"
          echo "Región: ${{ env.ENV == 'prod' && env.REGION_PROD || env.REGION_DEV }}"
          echo "Acción ejecutada: ${{ env.TF_ACTION }}"
          if [ "${{ github.event.inputs.skip_image_build }}" = "true" ]; then
            echo "Se omitió la construcción de imágenes"
          else
            echo "Se construyeron y publicaron las imágenes Docker"
          fi