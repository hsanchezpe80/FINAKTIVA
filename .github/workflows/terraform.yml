name: Infraestructura y Despliegue

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente a desplegar (dev, stg, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stg
          - prod
      terraform_action:
        description: 'Acción de Terraform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      skip_image_build:
        description: 'Omitir construcción de imágenes'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    name: Despliegue de Infraestructura
    runs-on: ubuntu-latest
    
    # Establecer el ambiente según el contexto
    env:
      # Por defecto usa 'dev' para develop branch, 'prod' para main, o el input manual
      ENV: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/develop' && 'dev') || 'dev' }}
      REGION_DEV: us-east-2
      REGION_STG: us-east-2
      REGION_PROD: us-west-2
      BUCKET_REGION_DEV: us-east-2
      BUCKET_REGION_STG: us-east-2
      BUCKET_REGION_PROD: us-west-2
      TF_ACTION: ${{ github.event.inputs.terraform_action || 'plan' }}
      
    steps:
      - name: Checkout del código
        uses: actions/checkout@v3
      
      - name: Configurar variables de región
        run: |
          # Definir la región de despliegue según el ambiente
          if [ "${{ env.ENV }}" = "prod" ]; then
            echo "DEPLOY_REGION=${{ env.REGION_PROD }}" >> $GITHUB_ENV
            echo "STATE_BUCKET_REGION=${{ env.BUCKET_REGION_PROD }}" >> $GITHUB_ENV
          elif [ "${{ env.ENV }}" = "stg" ]; then
            echo "DEPLOY_REGION=${{ env.REGION_STG }}" >> $GITHUB_ENV
            echo "STATE_BUCKET_REGION=${{ env.BUCKET_REGION_STG }}" >> $GITHUB_ENV
          else
            echo "DEPLOY_REGION=${{ env.REGION_DEV }}" >> $GITHUB_ENV
            echo "STATE_BUCKET_REGION=${{ env.BUCKET_REGION_DEV }}" >> $GITHUB_ENV
          fi
          
          echo "Ambiente: ${{ env.ENV }}"
          echo "Región de despliegue: $DEPLOY_REGION"
          echo "Región del bucket de estado: $STATE_BUCKET_REGION"
      
      - name: Configurar AWS CLI
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.DEPLOY_REGION }}
      
      - name: Obtener ID de cuenta AWS
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
      
      - name: Instalar Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.6
      
      # PASO 1: Configurar buckets para Terraform state
      - name: Crear y configurar buckets para Terraform state
        run: |
          echo "=== Creando buckets para Terraform state ==="
          
          # Crear buckets en sus regiones respectivas
          aws s3 mb s3://finaktiva-terraform-state-dev --region ${{ env.BUCKET_REGION_DEV }} || true
          aws s3 mb s3://finaktiva-terraform-state-stg --region ${{ env.BUCKET_REGION_STG }} || true
          aws s3 mb s3://finaktiva-terraform-state-prod --region ${{ env.BUCKET_REGION_PROD }} || true
          
          # Habilitar versionado
          aws s3api put-bucket-versioning --bucket finaktiva-terraform-state-dev --versioning-configuration Status=Enabled --region ${{ env.BUCKET_REGION_DEV }}
          aws s3api put-bucket-versioning --bucket finaktiva-terraform-state-stg --versioning-configuration Status=Enabled --region ${{ env.BUCKET_REGION_STG }}
          aws s3api put-bucket-versioning --bucket finaktiva-terraform-state-prod --versioning-configuration Status=Enabled --region ${{ env.BUCKET_REGION_PROD }}
          
          # Crear tabla DynamoDB para lock
          if [ "${{ env.ENV }}" = "prod" ]; then
            aws dynamodb create-table \
                --table-name terraform-state-lock \
                --attribute-definitions AttributeName=LockID,AttributeType=S \
                --key-schema AttributeName=LockID,KeyType=HASH \
                --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
                --region ${{ env.BUCKET_REGION_PROD }} || true
          else
            aws dynamodb create-table \
                --table-name terraform-state-lock \
                --attribute-definitions AttributeName=LockID,AttributeType=S \
                --key-schema AttributeName=LockID,KeyType=HASH \
                --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
                --region ${{ env.BUCKET_REGION_DEV }} || true
          fi
              
          echo "=== Configuración de Terraform state completada ==="
      
      # PASO 2: Crear repositorios ECR
      - name: Crear repositorios ECR
        run: |
          echo "=== Creando repositorios ECR ==="
          
          # Crear repositorios con nombres que coincidan con el módulo Terraform
          aws ecr delete-repository --repository-name ${{ env.ENV }}-app1 --force --region ${{ env.DEPLOY_REGION }} || true
          aws ecr delete-repository --repository-name ${{ env.ENV }}-app2 --force --region ${{ env.DEPLOY_REGION }} || true
          
          aws ecr create-repository --repository-name ${{ env.ENV }}-app1 --region ${{ env.DEPLOY_REGION }} || true
          aws ecr create-repository --repository-name ${{ env.ENV }}-app2 --region ${{ env.DEPLOY_REGION }} || true
          
          echo "=== Repositorios ECR creados correctamente ==="
      
      # PASO 3: Configurar módulo ECR
      - name: Configurar módulo ECR
        run: |
          ECR_MODULE_DIR="docs/terraform-iac/terraform/modulos/ecr"
          mkdir -p $ECR_MODULE_DIR
          
          # Data source para obtener los repositorios ECR existentes
          echo '# Data source para obtener los repositorios ECR existentes' > $ECR_MODULE_DIR/main.tf
          echo 'data "aws_ecr_repository" "app_repo" {' >> $ECR_MODULE_DIR/main.tf
          echo '  count = length(var.app_names)' >> $ECR_MODULE_DIR/main.tf
          echo '  name  = "${var.environment}-${var.app_names[count.index]}"' >> $ECR_MODULE_DIR/main.tf
          echo '}' >> $ECR_MODULE_DIR/main.tf
          
          # Crear o actualizar variables.tf
          if [ ! -f "$ECR_MODULE_DIR/variables.tf" ]; then
            echo "Creando variables.tf del módulo ECR..."
            echo 'variable "app_names" {' > $ECR_MODULE_DIR/variables.tf
            echo '  description = "Nombres de las aplicaciones"' >> $ECR_MODULE_DIR/variables.tf
            echo '  type        = list(string)' >> $ECR_MODULE_DIR/variables.tf
            echo '  default     = ["app1", "app2"]' >> $ECR_MODULE_DIR/variables.tf
            echo '}' >> $ECR_MODULE_DIR/variables.tf
            echo '' >> $ECR_MODULE_DIR/variables.tf
            echo 'variable "environment" {' >> $ECR_MODULE_DIR/variables.tf
            echo '  description = "Ambiente (dev, stg, prod)"' >> $ECR_MODULE_DIR/variables.tf
            echo '  type        = string' >> $ECR_MODULE_DIR/variables.tf
            echo '  default     = "dev"' >> $ECR_MODULE_DIR/variables.tf
            echo '}' >> $ECR_MODULE_DIR/variables.tf
          fi
          
          # Crear o actualizar outputs.tf
          if [ ! -f "$ECR_MODULE_DIR/outputs.tf" ]; then
            echo "Creando outputs.tf del módulo ECR..."
            echo 'output "repository_urls" {' > $ECR_MODULE_DIR/outputs.tf
            echo '  description = "URLs de los repositorios ECR"' >> $ECR_MODULE_DIR/outputs.tf
            echo '  value       = data.aws_ecr_repository.app_repo[*].repository_url' >> $ECR_MODULE_DIR/outputs.tf
            echo '}' >> $ECR_MODULE_DIR/outputs.tf
          fi
      
      # PASO 4: Asegurar que existan Dockerfiles
      - name: Asegurar que existan Dockerfiles
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        run: |
          # Verificar y crear Dockerfile para app1 si no existe
          if [ ! -f apps/app1/Dockerfile ]; then
            echo "Creando Dockerfile temporal para app1..."
            mkdir -p apps/app1/src
            
            echo 'FROM alpine:latest' > apps/app1/Dockerfile
            echo 'WORKDIR /app' >> apps/app1/Dockerfile
            echo 'COPY src/ .' >> apps/app1/Dockerfile
            echo 'CMD ["echo", "Esta es una imagen temporal para app1"]' >> apps/app1/Dockerfile
          fi
          
          # Verificar y crear Dockerfile para app2 si no existe
          if [ ! -f apps/app2/Dockerfile ]; then
            echo "Creando Dockerfile temporal para app2..."
            mkdir -p apps/app2/src
            
            echo 'FROM alpine:latest' > apps/app2/Dockerfile
            echo 'WORKDIR /app' >> apps/app2/Dockerfile
            echo 'COPY src/ .' >> apps/app2/Dockerfile
            echo 'CMD ["echo", "Esta es una imagen temporal para app2"]' >> apps/app2/Dockerfile
          fi
          
          # Verificar que los directorios src contengan al menos un archivo
          if [ ! "$(ls -A apps/app1/src 2>/dev/null)" ]; then
            echo "Creando archivo de ejemplo en app1/src..."
            echo "console.log('Aplicación 1');" > apps/app1/src/index.js
          fi
          
          if [ ! "$(ls -A apps/app2/src 2>/dev/null)" ]; then
            echo "Creando archivo de ejemplo en app2/src..."
            echo "console.log('Aplicación 2');" > apps/app2/src/index.js
          fi
      
      # PASO 5: Autenticar, construir y publicar imágenes Docker a ECR
      - name: Configurar Docker Buildx
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        uses: docker/setup-buildx-action@v2
      
      - name: Autenticar en ECR
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        id: ecr-login
        run: |
          aws ecr get-login-password --region ${{ env.DEPLOY_REGION }} | docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.DEPLOY_REGION }}.amazonaws.com
      
      - name: Construir y publicar imagen app1
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        uses: docker/build-push-action@v4
        with:
          context: ./apps/app1
          push: true
          tags: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.DEPLOY_REGION }}.amazonaws.com/${{ env.ENV }}-app1:latest
      
      - name: Construir y publicar imagen app2
        if: ${{ github.event.inputs.skip_image_build != 'true' }}
        uses: docker/build-push-action@v4
        with:
          context: ./apps/app2
          push: true
          tags: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.DEPLOY_REGION }}.amazonaws.com/${{ env.ENV }}-app2:latest
      
      # PASO 6: Preparar y ejecutar Terraform
      - name: Preparar archivos de Terraform
        run: |
          TERRAFORM_DIR="docs/terraform-iac/terraform"
          mkdir -p $TERRAFORM_DIR
          
          # Crear o actualizar backend.tf
          echo 'terraform {' > $TERRAFORM_DIR/backend.tf
          echo '  backend "s3" {' >> $TERRAFORM_DIR/backend.tf
          echo '    # Los valores específicos se pasan en la línea de comandos de init' >> $TERRAFORM_DIR/backend.tf
          echo '  }' >> $TERRAFORM_DIR/backend.tf
          echo '}' >> $TERRAFORM_DIR/backend.tf
          
          # Asegurar que main.tf referencia al módulo ECR
          echo 'provider "aws" {' > $TERRAFORM_DIR/main.tf
          echo '  region = var.region' >> $TERRAFORM_DIR/main.tf
          echo '}' >> $TERRAFORM_DIR/main.tf
          echo '' >> $TERRAFORM_DIR/main.tf
          echo '# Módulo ECR' >> $TERRAFORM_DIR/main.tf
          echo 'module "ecr" {' >> $TERRAFORM_DIR/main.tf
          echo '  source      = "./modulos/ecr"' >> $TERRAFORM_DIR/main.tf
          echo '  environment = var.environment' >> $TERRAFORM_DIR/main.tf
          echo '  app_names   = ["app1", "app2"]' >> $TERRAFORM_DIR/main.tf
          echo '}' >> $TERRAFORM_DIR/main.tf
          
          # Verificar variables.tf
          echo 'variable "environment" {' > $TERRAFORM_DIR/variables.tf
          echo '  description = "Ambiente (dev, stg, prod)"' >> $TERRAFORM_DIR/variables.tf
          echo '  type        = string' >> $TERRAFORM_DIR/variables.tf
          echo '  default     = "dev"' >> $TERRAFORM_DIR/variables.tf
          echo '}' >> $TERRAFORM_DIR/variables.tf
          echo '' >> $TERRAFORM_DIR/variables.tf
          echo 'variable "region" {' >> $TERRAFORM_DIR/variables.tf
          echo '  description = "Región de AWS"' >> $TERRAFORM_DIR/variables.tf
          echo '  type        = string' >> $TERRAFORM_DIR/variables.tf
          echo '  default     = "us-east-2"' >> $TERRAFORM_DIR/variables.tf
          echo '}' >> $TERRAFORM_DIR/variables.tf
          
          # Verificar archivos de ambiente
          mkdir -p $TERRAFORM_DIR/ambientes/${{ env.ENV }}
          
          # Crear el archivo terraform.tfvars
          echo "environment = \"${{ env.ENV }}\"" > $TERRAFORM_DIR/ambientes/${{ env.ENV }}/terraform.tfvars
          echo "region = \"${{ env.DEPLOY_REGION }}\"" >> $TERRAFORM_DIR/ambientes/${{ env.ENV }}/terraform.tfvars
      
      - name: Plan de Terraform
        if: ${{ env.TF_ACTION == 'plan' || env.TF_ACTION == 'apply' }}
        run: |
          cd docs/terraform-iac/terraform
          
          # Mostrar la versión de Terraform
          terraform version
          
          # Limpiar completamente el directorio de terraform
          echo "Limpiando estado de Terraform..."
          rm -rf .terraform* terraform.tfstate* tfplan
          
          # ======= ENFOQUE DESDE CERO ABSOLUTO =======
          # Crear un nuevo directorio limpio para asegurarnos de que no hay estado residual
          mkdir -p clean_terraform
          cp -r * clean_terraform/
          cd clean_terraform
          
          # Forzar el uso de un estado local en lugar de S3
          cat > backend.tf << EOF
          terraform {
            backend "local" {}
          }
          EOF
          
          # Inicializar en el directorio limpio
          echo "Inicializando Terraform en directorio limpio..."
          terraform init
          
          # Verificar la infraestructura actual en AWS
          echo "Verificando recursos en AWS..."
          echo "ECR Repositories:"
          aws ecr describe-repositories --query "repositories[?contains(repositoryName, '${{ env.ENV }}')].repositoryName" --output table || echo "No hay repositorios ECR"
          
          echo "ECS Clusters:"
          aws ecs list-clusters --query "clusterArns[*]" --output table || echo "No hay clusters ECS"
          
          echo "VPCs con tag ${{ env.ENV }}:"
          aws ec2 describe-vpcs --filters "Name=tag:Name,Values=*${{ env.ENV }}*" --query "Vpcs[*].{ID:VpcId,CIDR:CidrBlock,Name:Tags[?Key=='Name'].Value|[0]}" --output table || echo "No hay VPCs con el tag ${{ env.ENV }}"
          
          # Forzar plan ignorando el estado completamente
          echo "Ejecutando terraform plan desde cero absoluto..."
          terraform plan \
            -var="environment=${{ env.ENV }}" \
            -var="region=${{ env.DEPLOY_REGION }}" \
            -var-file="../ambientes/${{ env.ENV }}/terraform.tfvars" \
            -refresh=false \
            -input=false | tee fresh_plan.txt
          
          # Capturar el resumen del plan
          FRESH_PLAN_SUMMARY=$(grep "Plan:" fresh_plan.txt || echo "No se encontró resumen del plan")
          RESOURCES_COUNT=$(grep -c "will be created" fresh_plan.txt || echo "0")
          
          # Mostrar resultados
          echo "============================================================"
          echo "RESUMEN DE RECURSOS A CREAR (DESDE CERO ABSOLUTO)"
          echo "============================================================"
          echo "$FRESH_PLAN_SUMMARY"
          echo "Total de recursos a crear: $RESOURCES_COUNT"
          
          if [ "$RESOURCES_COUNT" -gt "0" ]; then
            echo ""
            echo "RECURSOS A CREAR:"
            grep "will be created" fresh_plan.txt | sort | head -20
            
            if [ "$RESOURCES_COUNT" -gt "20" ]; then
              echo "... y $(($RESOURCES_COUNT - 20)) recursos más."
            fi
          fi
          
          # Volver al directorio original
          cd ..
          
          # Si el plan desde cero mostró recursos para crear, usamos ese mismo enfoque para el plan final
          if [ "$RESOURCES_COUNT" -gt "0" ]; then
            echo ""
            echo "============================================================"
            echo "FORZANDO CREACIÓN IGNORANDO ESTADO S3"
            echo "============================================================"
            echo "Se detectaron $RESOURCES_COUNT recursos a crear. Configurando plan final para ignorar estado existente."
            
            # Usar backend local para el plan final
            cat > backend.tf << EOF
            terraform {
              backend "local" {}
            }
            EOF
            
            # Inicializar con backend local
            terraform init -reconfigure
            
            # Ejecutar plan final forzando refresh false
            terraform plan \
              -var="environment=${{ env.ENV }}" \
              -var="region=${{ env.DEPLOY_REGION }}" \
              -var-file="ambientes/${{ env.ENV }}/terraform.tfvars" \
              -refresh=false \
              -out=tfplan \
              -input=false | tee plan_output.txt
          else
            echo ""
            echo "============================================================"
            echo "ADVERTENCIA: NO SE DETECTARON RECURSOS A CREAR"
            echo "============================================================"
            echo "Incluso con un enfoque desde cero absoluto, Terraform no detectó recursos para crear."
            echo "Esto sugiere un problema con la configuración de Terraform o con los módulos."
            echo ""
            echo "Verificando módulos y configuración..."
            
            # Usar backend S3 para el plan final
            cat > backend.tf << EOF
            terraform {
              backend "s3" {
                # Los valores específicos se pasan en la línea de comandos de init
              }
            }
            EOF
            
            # Inicializar con backend S3
            terraform init -reconfigure \
              -backend-config="bucket=finaktiva-terraform-state-${{ env.ENV }}" \
              -backend-config="key=terraform.tfstate" \
              -backend-config="region=${{ env.STATE_BUCKET_REGION }}" \
              -backend-config="dynamodb_table=terraform-state-lock"
            
            # Ejecutar plan final normal
            terraform plan \
              -var="environment=${{ env.ENV }}" \
              -var="region=${{ env.DEPLOY_REGION }}" \
              -var-file="ambientes/${{ env.ENV }}/terraform.tfvars" \
              -out=tfplan \
              -input=false | tee plan_output.txt
          fi
          
          # Si es solo plan, mostramos un mensaje explicativo
          if [ "${{ env.TF_ACTION }}" = "plan" ]; then
            echo ""
            echo "============================================================"
            echo "Plan de Terraform completado. No se aplicarán cambios."
            echo "Para aplicar estos cambios, ejecuta el workflow con la acción 'apply'."
            echo "============================================================"
          fi
      
      - name: Inicializar Terraform
        run: |
          cd docs/terraform-iac/terraform
          
          # Usamos la región específica para el bucket de estado según el ambiente
          terraform init \
            -backend-config="bucket=finaktiva-terraform-state-${{ env.ENV }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.STATE_BUCKET_REGION }}" \
            -backend-config="dynamodb_table=terraform-state-lock"
      
      # Aplicar cambios si la acción es 'apply' y no es un PR
      - name: Aplicar Terraform
        if: ${{ env.TF_ACTION == 'apply' && github.event_name != 'pull_request' }}
        run: |
          cd docs/terraform-iac/terraform
          echo "============================================================"
          echo "Aplicando cambios de infraestructura en ambiente ${{ env.ENV }}..."
          echo "============================================================"
          terraform apply -auto-approve tfplan
      
      # Destruir infraestructura si la acción es 'destroy'
      - name: Destruir infraestructura
        if: ${{ env.TF_ACTION == 'destroy' && github.event_name != 'pull_request' }}
        run: |
          cd docs/terraform-iac/terraform
          
          echo "============================================================"
          echo "ATENCIÓN: Se destruirá toda la infraestructura en ambiente ${{ env.ENV }}."
          echo "============================================================"
          
          terraform destroy -auto-approve \
            -var="environment=${{ env.ENV }}" \
            -var="region=${{ env.DEPLOY_REGION }}" \
            -var-file="ambientes/${{ env.ENV }}/terraform.tfvars"
      
      - name: Notificar completado
        run: |
          echo "============================================================"
          echo "Pipeline completado exitosamente"
          echo "============================================================"
          echo "Ambiente: ${{ env.ENV }}"
          echo "Región para recursos: ${{ env.DEPLOY_REGION }}"
          echo "Región para estado en S3: ${{ env.STATE_BUCKET_REGION }}"
          echo "Acción ejecutada: ${{ env.TF_ACTION }}"
          if [ "${{ github.event.inputs.skip_image_build }}" = "true" ]; then
            echo "Se omitió la construcción de imágenes"
          else
            echo "Se construyeron y publicaron las imágenes Docker"
          fi